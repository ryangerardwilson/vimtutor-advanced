===============================================================================
=    W e l c o m e   t o   t h e   V I M   T u t o r  ADVANCED                =
===============================================================================

    This is an opinionated variant of Vim Tutor cooked up by Ryan Gerard Wilson
    (check ryangerardwilson.com if you want the full story), zeroing in on the
    workflows he swears by—the ones that actually save your ass when you're
    knee-deep in code without turning into a mouse-clicking zombie. We've
    jammed in advanced features the basic tutor ignores, like macros, visual
    blocks, and indent voodoo, because why pretend editing is just "hjkl and
    pray"?

    Lessons 1 to 6 are straight from the original vimtutor version 1.5—solid
    basics, no arguments there—but lesson 7 is where the juice is. That's where
    we crank it up and teach you to actually bend Vim to your will instead of
    just poking it like a scared kitten.

    It'll take you 25-30 minutes if you're not a complete space cadet, but
    factor in extra if you insist on experimenting instead of just doing what
    it says.  Hell, experimentation is half the fun—Vim rewards the bold,
    punishes the lazy.

    These lessons will butcher the text, so make a copy of this file to screw
    around with (if you fired up vimtutor, it's already cloned—thank me later).
    Listen, this ain't a bedtime story; it's hands-on boot camp. Type the
    commands, feel the pain, or you'll forget 'em faster than a kernel panic
    log. Reading alone? That's for wimps who think Ctrl+Z is "undo" magic.

    Alright, caps lock off, you caveman—hit j enough times to scroll Lesson 1.1
    into view. Let's make you dangerous.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			Lesson 1.1:  MOVING THE CURSOR


   ** To move the cursor, press the h,j,k,l keys as indicated. **
	     ^
	     k		    Hint:  The h key is at the left and moves left.
       < h	 l >		   The l key is at the right and moves right.
	     j			   The j key looks like a down arrow
	     v
  1. Move the cursor around the screen until you are comfortable.

  2. Hold down the down key (j) until it repeats.
---> Now you know how to move to the next lesson.

  3. Using the down key, move to Lesson 1.2.

Note: If you are ever unsure about something you typed, press <ESC> to place
      you in Normal mode.  Then retype the command you wanted.

Note: The cursor keys should also work.  But using hjkl you will be able to
      move around much faster, once you get used to it.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		     Lesson 1.2: ENTERING AND EXITING VIM


  !! NOTE: Before executing any of the steps below, read this entire lesson!!

  1. Press the <ESC> key (to make sure you are in Normal mode).

  2. Type:			:q! <ENTER>.

---> This exits the editor WITHOUT saving any changes you have made.
     If you want to save the changes and exit type:
				:wq  <ENTER>

  3. When you see the shell prompt, type the command that got you into this
     tutor.  That could be:	vimtutor <ENTER>
     Normally you would use:	vim tutor <ENTER>

---> 'vim' means enter the vim editor, 'tutor' is the file you wish to edit.

  4. If you have these steps memorized and are confident, execute steps
     1 through 3 to exit and re-enter the editor.  Then move the cursor down
     to Lesson 1.3.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		     Lesson 1.3: TEXT EDITING - DELETION

While in Normal mode press	x  to delete the character under the cursor.

  1. Move the cursor to the line below marked --->.

  2. To fix the errors, move the cursor until it is on top of the
     character to be deleted.

  3. Press the	x  key to delete the unwanted character.

  4. Repeat steps 2 through 4 until the sentence is correct.

---> The ccow jumpedd ovverr thhe mooon.

  5. Now that the line is correct, go on to Lesson 1.4.

NOTE: As you go through this tutor, do not try to memorize, learn by usage.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		     Lesson 1.4: TEXT EDITING - INSERTION

While in Normal mode press  i  to insert text. 

  1. Move the cursor to the first line below marked --->.

  2. To make the first line the same as the second, move the cursor on top
     of the first character AFTER where the text is to be inserted.

  3. Press  i  and type in the necessary additions.

  4. As each error is fixed press <ESC> to return to Normal mode.
     Repeat steps 2 through 4 to correct the sentence.

---> There is text misng this .
---> There is some text missing from this line.

  5. When you are comfortable inserting text move to the summary below.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			       LESSON 1 SUMMARY


  1. The cursor is moved using either the arrow keys or the hjkl keys.
	 h (left)	j (down)       k (up)	    l (right)

  2. To enter Vim (from the % prompt) type:  vim FILENAME <ENTER>

  3. To exit Vim type:	   <ESC>   :q!	 <ENTER>  to trash all changes.
	     OR type:	   <ESC>   :wq	 <ENTER>  to save the changes.

  4. To delete a character under the cursor in Normal mode type:  x

  5. To insert text at the cursor while in Normal mode type:
	 i     type in text	<ESC>

NOTE: Pressing <ESC> will place you in Normal mode or will cancel
      an unwanted and partially completed command.

Now continue with Lesson 2.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			Lesson 2.1: DELETION COMMANDS


	    ** Type  dw  to delete to the end of a word. **

  1. Press  <ESC>  to make sure you are in Normal mode.

  2. Move the cursor to the line below marked --->.

  3. Move the cursor to the beginning of a word that needs to be deleted.

  4. Type   dw	 to make the word disappear.

  NOTE: The letters dw will appear on the last line of the screen as you type
	them. If you typed something wrong, press  <ESC>  and start over.

---> There are a some words fun that don't belong paper in this sentence.

  5. Repeat steps 3 and 4 until the sentence is correct and go to Lesson 2.2.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		      Lesson 2.2: MORE DELETION COMMANDS


	   ** Type  d$	to delete to the end of the line. **

  1. Press  <ESC>  to make sure you are in Normal mode.

  2. Move the cursor to the line below marked --->.

  3. Move the cursor to the end of the correct line (AFTER the first . ).

  4. Type    d$    to delete to the end of the line.

---> Somebody typed the end of this line twice. end of this line twice.


  5. Move on to Lesson 2.3 to understand what is happening.





~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		     Lesson 2.3: ON COMMANDS AND OBJECTS


  The format for the  d  delete command is as follows:

	 [number]   d	object	    OR	     d	 [number]   object
  Where:
    number - is how many times to execute the command (optional, default=1).
    d - is the command to delete.
    object - is what the command will operate on (listed below).

  A short list of objects:
    w - from the cursor to the end of the word, including the space.
    e - from the cursor to the end of the word, NOT including the space.
    $ - from the cursor to the end of the line.

NOTE:  For the adventurous, pressing just the object while in Normal mode
       without a command will move the cursor as specified in the object list.




~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		Lesson 2.4: AN EXCEPTION TO  'COMMAND-OBJECT'


	       ** Type	 dd   to delete a whole line. **

  Due to the frequency of whole line deletion, the designers of Vim decided
  it would be easier to simply type two d's in a row to delete a line.

  1. Move the cursor to the second line in the phrase below.
  2. Type  dd  to delete the line.
  3. Now move to the fourth line.
  4. Type   2dd   (remember  number-command-object) to delete the two lines.

      1)  Roses are red,
      2)  Mud is fun,
      3)  Violets are blue,
      4)  I have a car,
      5)  Clocks tell time,
      6)  Sugar is sweet
      7)  And so are you.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 Lesson 2.5: THE UNDO COMMAND


   ** Press  u	to undo the last commands,   U	 to fix a whole line. **

  1. Move the cursor to the line below marked ---> and place it on the
     first error.
  2. Type  x  to delete the first unwanted character.
  3. Now type  u  to undo the last command executed.
  4. This time fix all the errors on the line using the  x  command.
  5. Now type a capital  U  to return the line to its original state.
  6. Now type  u  a few times to undo the  U  and preceding commands.
  7. Now type CTRL-R (keeping CTRL key pressed while hitting R) a few times
     to redo the commands (undo the undo's).

---> Fiix the errors oon thhis line and reeplace them witth undo.

  8. These are very useful commands.  Now move on to the Lesson 2 Summary.




~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			       LESSON 2 SUMMARY


  1. To delete from the cursor to the end of a word type:    dw

  2. To delete from the cursor to the end of a line type:    d$

  3. To delete a whole line type:    dd

  4. The format for a command in Normal mode is:

       [number]   command   object     OR     command	[number]   object
     where:
       number - is how many times to repeat the command
       command - is what to do, such as  d  for delete
       object - is what the command should act upon, such as  w (word),
		$ (to the end of line), etc.

  5. To undo previous actions, type:	     u	 (lowercase u)
     To undo all the changes on a line type: U	 (capital U)
     To undo the undo's type:		     CTRL-R

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 Lesson 3.1: THE PUT COMMAND


       ** Type	p  to put the last deletion after the cursor. **

  1. Move the cursor to the first line in the set below.

  2. Type  dd  to delete the line and store it in Vim's buffer.

  3. Move the cursor to the line ABOVE where the deleted line should go.

  4. While in Normal mode, type    p	 to replace the line.

  5. Repeat steps 2 through 4 to put all the lines in correct order.

     d) Can you learn too?
     b) Violets are blue,
     c) Intelligence is learned,
     a) Roses are red,



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		       Lesson 3.2: THE REPLACE COMMAND


  ** Type  r  and a character to replace the character under the cursor. **

  1. Move the cursor to the first line below marked --->.

  2. Move the cursor so that it is on top of the first error.

  3. Type   r	and then the character which should replace the error.

  4. Repeat steps 2 and 3 until the first line is correct.

--->  Whan this lime was tuoed in, someone presswd some wrojg keys!
--->  When this line was typed in, someone pressed some wrong keys!

  5. Now move on to Lesson 3.2.

NOTE: Remember that you should be learning by use, not memorization.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			Lesson 3.3: THE CHANGE COMMAND


	   ** To change part or all of a word, type  cw . **

  1. Move the cursor to the first line below marked --->.

  2. Place the cursor on the u in lubw.

  3. Type  cw  and the correct word (in this case, type  'ine'.)

  4. Press <ESC> and move to the next error (the first character to be changed.)

  5. Repeat steps 3 and 4 until the first sentence is the same as the second.

---> This lubw has a few wptfd that mrrf changing usf the change command.
---> This line has a few words that need changing using the change command.

Notice that  cw  not only replaces the word, but also places you in insert.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		       Lesson 3.4: MORE CHANGES USING c


     ** The change command is used with the same objects as delete. **

  1. The change command works in the same way as delete.  The format is:

       [number]   c   object	   OR	    c	[number]   object

  2. The objects are also the same, such as   w (word), $ (end of line), etc.

  3. Move to the first line below marked --->.

  4. Move the cursor to the first error.

  5. Type  c$  to make the rest of the line like the second and press <ESC>.

---> The end of this line needs some help to make it like the second.
---> The end of this line needs to be corrected using the  c$  command.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			       LESSON 3 SUMMARY


  1. To replace text that has already been deleted, type   p .	This Puts the
     deleted text AFTER the cursor (if a line was deleted it will go on the
     line below the cursor).

  2. To replace the character under the cursor, type   r   and then the
     character which will replace the original.

  3. The change command allows you to change the specified object from the
     cursor to the end of the object.  eg. Type  cw  to change from the
     cursor to the end of the word, c$	to change to the end of a line.

  4. The format for change is:

	 [number]   c	object	      OR	c   [number]   object

Now go on to the next lesson.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		     Lesson 4.1: LOCATION AND FILE STATUS


  ** Type CTRL-g to show your location in the file and the file status.
     Type SHIFT-G to move to a line in the file. **

  Note: Read this entire lesson before executing any of the steps!!

  1. Hold down the Ctrl key and press  g .  A status line will appear at the
     bottom of the page with the filename and the line you are on.  Remember
     the line number for Step 3.

  2. Press shift-G to move you to the bottom of the file.

  3. Type in the number of the line you were on and then shift-G.  This will
     return you to the line you were on when you first pressed Ctrl-g.
     (When you type in the numbers, they will NOT be displayed on the screen.)

  4. If you feel confident to do this, execute steps 1 through 3.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			Lesson 4.2: THE SEARCH COMMAND


     ** Type  /  followed by a phrase to search for the phrase. **

  1. In Normal mode type the  /  character.  Notice that it and the cursor
     appear at the bottom of the screen as with the  :	command.

  2. Now type 'errroor' <ENTER>.  This is the word you want to search for.

  3. To search for the same phrase again, simply type  n .
     To search for the same phrase in the opposite direction, type  Shift-N .

  4. If you want to search for a phrase in the backwards direction, use the
     command  ?  instead of /.

---> When the search reaches the end of the file it will continue at the start.

  "errroor" is not the way to spell error;  errroor is an error.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		   Lesson 4.3: MATCHING PARENTHESES SEARCH


	      ** Type  %  to find a matching ),], or } . **

  1. Place the cursor on any (, [, or { in the line below marked --->.

  2. Now type the  %  character.

  3. The cursor should be on the matching parenthesis or bracket.

  4. Type  %  to move the cursor back to the first bracket (by matching).

---> This ( is a test line with ('s, ['s ] and {'s } in it. ))

Note: This is very useful in debugging a program with unmatched parentheses!






~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		      Lesson 4.4: A WAY TO CHANGE ERRORS


	** Type  :s/old/new/g  to substitute 'new' for 'old'. **

  1. Move the cursor to the line below marked --->.

  2. Type  :s/thee/the <ENTER> .  Note that this command only changes the
     first occurrence on the line.

  3. Now type	 :s/thee/the/g	   meaning substitute globally on the line.
     This changes all occurrences on the line.

---> thee best time to see thee flowers is in thee spring.

  4. To change every occurrence of a character string between two lines,
     type   :#,#s/old/new/g    where #,# are the numbers of the two lines.
     Type   :%s/old/new/g    to change every occurrence in the whole file.




~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			       LESSON 4 SUMMARY


  1. Ctrl-g  displays your location in the file and the file status.
     Shift-G  moves to the end of the file.  A line number followed
     by  Shift-G  moves to that line number.

  2. Typing  /	followed by a phrase searches FORWARD for the phrase.
     Typing  ?	followed by a phrase searches BACKWARD for the phrase.
     After a search type  n  to find the next occurrence in the same direction
     or  Shift-N  to search in the opposite direction.

  3. Typing  %	while the cursor is on a  (,),[,],{, or }  locates its
     matching pair.

  4. To substitute new for the first old on a line type    :s/old/new
     To substitute new for all 'old's on a line type	   :s/old/new/g
     To substitute phrases between two line #'s type	   :#,#s/old/new/g
     To substitute all occurrences in the file type	   :%s/old/new/g
     To ask for confirmation each time add 'c'		   :%s/old/new/gc


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		Lesson 5.1: HOW TO EXECUTE AN EXTERNAL COMMAND


   ** Type  :!	followed by an external command to execute that command. **

  1. Type the familiar command	:  to set the cursor at the bottom of the
     screen.  This allows you to enter a command.

  2. Now type the  !  (exclamation point) character.  This allows you to
     execute any external shell command.

  3. As an example type   ls   following the ! and then hit <ENTER>.  This
     will show you a listing of your directory, just as if you were at the
     shell prompt.  Or use   :!dir  if ls doesn't work.

---> Note:  It is possible to execute any external command this way.

---> Note:  All  :  commands must be finished by hitting <ENTER>





~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			       LESSON 5 SUMMARY


  1.  :!command  executes an external command.

      Some useful examples are (MS-DOS):
	  :!dir			-  shows a directory listing.
	  :!del FILENAME	-  removes file FILENAME.

  2.  :w FILENAME  writes the current Vim file to disk with name FILENAME.

  3.  :#,#w FILENAME  saves the lines # through # in file FILENAME.

  4.  :r FILENAME  retrieves disk file FILENAME and inserts it into the
      current file following the cursor position.







~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 Lesson 6.1: THE OPEN COMMAND


 ** Type  o  to open a line below the cursor and place you in Insert mode. **

  1. Move the cursor to the line below marked --->.

  2. Type  o (lowercase) to open up a line BELOW the cursor and place you in
     Insert mode.

  3. Now copy the line marked ---> and press <ESC> to exit Insert mode.

---> After typing  o  the cursor is placed on the open line in Insert mode.

  4. To open up a line ABOVE the cursor, simply type a capital	O , rather
     than a lowercase  o.  Try this on the line below.
Open up a line above this by typing Shift-O while the cursor is on this line.





~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			Lesson 6.2: THE APPEND COMMAND


	     ** Type  a  to insert text AFTER the cursor. **

  1. Move the cursor to the end of the first line below marked ---> by
     typing  $	in Normal mode.

  2. Type an  a  (lowercase) to append text AFTER the character under the
     cursor.  (Uppercase  A  appends to the end of the line.)

Note: This avoids typing  i , the last character, the text to insert, <ESC>,
      cursor-right, and finally, x , just to append to the end of a line!

  3. Now complete the first line.  Note also that append is exactly the same
     as Insert mode, except for the location where text is inserted.

---> This line will allow you to practice
---> This line will allow you to practice appending text to the end of a line.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		    Lesson 6.3: ANOTHER VERSION OF REPLACE


      ** Type a capital  R  to replace more than one character. **

  1. Move the cursor to the first line below marked --->.

  2. Place the cursor at the beginning of the first word that is different
     from the second line marked ---> (the word 'last').

  3. Now type  R  and replace the remainder of the text on the first line by
     typing over the old text to make the first line the same as the second.

---> To make the first line the same as the last on this page use the keys.
---> To make the first line the same as the second, type R and the new text.

  4. Note that when you press <ESC> to exit, any unaltered text remains.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			       LESSON 6 SUMMARY


  1. Typing  o	opens a line BELOW the cursor and places the cursor on the open
     line in Insert mode.
     Typing a capital  O  opens the line ABOVE the line the cursor is on.

  2. Type an  a  to insert text AFTER the character the cursor is on.
     Typing a capital  A  automatically appends text to the end of the line.

  3. Typing a capital  R  enters Replace mode until  <ESC>  is pressed to exit.






~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

                LESSON 7.1: GOOD HABITS TO DEVELOP OUTSIDE VIM TO OPTIMIZE GOOD
                MUSCLE MEMORY.

  1. Eliminate your need to use the arrow keys in the default terminal.  

    1a. Add this to your .bashrc

set -o vi

    1b. Now, your terminal is by default in insert mode. Type anything, then
    hit Esc to enter normal mode. You will notice that your normal mode
    nvaigation commands are working here.

    1c. Now, for your terminal history, Esc into normal mode, and hit /, and
    type what you are searching for, and hit Enter. Now use n/N to toggle
    through the search items. Once you fing what you are looking for, use
    Ctrl+i/A to edit it, or simply hit Enter to execute it.

    1d. for terminal history: Get into normal mode, and use j/k to go to your
    previous/next commands.

    1e. Using the full vim editor for your commands: Type some gibberish in
    insert mode, then escape into normal mode, and hit v. Once you exit,
    whatever you typed will execute.

    1f. remap your terminal navigation to use Alt+h/l for prev/next tabs,
    instead of arrow key based approaches.

  2. Eliminate using arrow keys in web browsers and other apps.

    2a. use Ctrl+l to type in the address bar, with tab/ shift+tab to navigate
    that menu.

    2b. remap your browser navigation to use Alt+h/l for prev/next tabs
    
    2c. remap to use Ctrl+u/d for scroll up/down.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
             Lesson 7.2: MOVING TO THE START OR END OF A LINE

$ catapults to the end of the line. <End> key does the same if you're not a
purist.  ^ rockets to the first non-blank character—ignores leading spaces. 0
or <Home> nails the absolute beginning.

  1. Cursor on "the" in the line below. Type $ to end.

      Indented code is the devil's work, but sometimes necessary.

  2. Then ^ to first non-space.

  3. Now, consider the below. 0 to start.

--> Hello world.
--> Goodbye cruel world.

  4. From start, 2$ to end of next line.

  5. Now go to the last line below, and use - to move to the start of the line
  above.

--> Hello world.
--> Goodbye cruel world.
--> Hello world2.
--> Goodbye cruel world2.

  6. Then, use 2- to move 2 lines up.

  7. Notice that using - repeatedly helps you move upwards along the start of
  the start of each line, and using + repeatedly helps you move downwards along
  the end start of each line.  However, we can simply use 0, followed by the j
  or k keys instead of + and -.

  8. Now, to move up/ down along the end of each line, first use 0 or $,
  followed by the j or k keys.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            7.3 SEARCHING ALONG A SINGLE LINE

f x hunts forward for character x—lands on it. F backward. t x stops one before
x.  T backward. Counts work: 2f o finds second 'o'. Screw up? <esc> aborts.

  1. Start at beginning. fh to "human" h.

--> To err is human; to really foul things up requires a computer.

  2. Now fy to "really" y.

  3. Then from there, 2f<space> to skip two spaces.

  4. From end, F e back to first e. 

  5. From start of the line, t e to go before the first e. Likewise, T e takes
  you after the last e.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            7.4 EDITING IN INSERT MODE WITH CTRL+O CHEATS AND TARGETED DELETES

Ctrl+O f x jumps forward to next x on line—lands on it. Counts: 3f o for third
'o'. Ctrl+O F x backward. Ctrl+O C changes (deletes) from cursor to line end,
stays inserted. Ctrl+O ^ to first non-blank char. Ctrl+O $ to end of line.
Ctrl+O A appends at end. Ctrl+O t indents line; Ctrl+O d unindents. For deletes
in normal: d f x nukes forward to/including x. d F x backward including. d t x
up to but excluding x forward. d T x backward excluding. Counts work. Screw up?
u undoes.

  1. Entering Insert Mode with Precision: 

    1a. Half the battle is won by going into insert mode accurately. The first
    thing to notice is that i takes you into insert mode, at the exact position
    of the cursor. a takes you to insert mode after the position of the cursor.
    I takes you at the begining of the line, and A takes you to the end of the
    line.

--> Computer science is no more about computers than astronomy is about telescopes. 

    1b. The second thing to notice is that cw takes you to insert mode to
    change a word, cc takes you into insert mode to change the line afer the
    first non-whitespace character, and C takes you into insert mode to change
    the rest of the line from wherever your cursor is at.

--> Computer science is no more about computers than astronomy is about telescopes. 

  2. Native Insert Mode Commands

    2a. While in insert mode, use Ctrl+T/D to indent/de-indent the line. No
    need to use the Ctrl+O flag for this. 

  3. While, we will discuss how to delete in insert mode, the cold hard truth
  is that, if it can't be done with a simple Ctrl+H, the easiest way to delete
  is to use select while in normal mode, followed by x. So, make this your
  primary habit.

  4. Boring stuff to make peace with in Insert Mode

    4a. CAPS lock is the best way to capitalize if you are gonna type a whole
    lot of capitalized text. SO DON'T USE IT!!!!!! Instead, type out the entire
    text in lower case, and use ~ in normal mode (post a selection) to
    capitalize everything).

    4b. The DELETE key is the best way to delete forwards. SO DON'T USE IT!!!
    Instead, go into normal mode to delete forwards with ease, and, in any
    case, Ctrl+h works perfectly for backspace in insert mode.

  5. Stuff you should NEVER do in Insert Mode for good muscle memory:

    5a. NEVER use arrow keys to navigate. Simply escape to normal mode to
    navigate.  Normal mode is optimized for this shit, dont be tempted by the
    existence of the arrow keys.

    5b. NEVER use the delete key to backspace. Use Ctrl+H. Its hard to
    reposition your fingers for touch typing after hitting the delete key
    because of the horrible layout of most keyboards.

  6. Useful Normal Mode Commands in Insert Mode: 

    6a. Start inserted after "more".  Ctrl+O f c to "computers", Ctrl+O cw,
    allows you to change it to cats. Then, Ctrl+O C allows you to retype "than
    dogs are about kibble."

--> Computer science is no more about computers than astronomy is about telescopes. 

    6b. Now, start inserted after "more" again, and use Ctrl+O F C to
    "Computers".

    6c. To delete characters in insert mode use Ctrl+H/Backspace to delete
    backwards, and Delete to delete forwards. While Ctrl+H is great for touch
    typists, there is, sadly, no pleasent alternative for Delete. Given that
    Ctrl+O x, is not a very pleasent experience, to delete forwards, you have
    one of two choices: (a) use x in normal mode; or (b) use d t e as indicated
    in point 6d below.

    6d. Use Ctrl+O, followed by d t e delete up to but not including first e in
    "Computer". Hit Ctrl+O u to undo.


--> Computer science is no more about computers than astronomy is about telescopes. 

    6f. End of line, Ctrl+O A to append, type "—it's all about the coffee "
    (don't forget the extra space at the end, as using Ctrl+O subsequently,
    will move the cursor one space back), then Ctrl+O, d F - to nuke backwards
    deleting what we just typed.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            7.5 MOVING TO A SPECIFIC LINE

G with number: 5G to line 5. No number? Bottom of file. Beats your idiotic gg
or 9999k nonsense.

  1. Type :set number to see lines (or not, whatever).

  2. Then 721G top.

--> Line 1: Foo bar baz
--> Line 2: Quux quuux
--> Line 3: Hello there
--> Line 4: World peace
--> Line 5: End of story

  3. 723G line 3.

  4. G bottom of the page. Now :set nonumber if you hate numbers.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            7.6 SCROLLING UP AND DOWN

<c-u> scrolls half-screen up (text moves down). <c-d> half-screen down. Smooth
sailing, no jarring jumps.</c-d></c-u>

  1. Scroll down with <c-d> twice.

--> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat.

--> More filler: Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</c-d>

  2. Up with <c-u>.

  3. Repeat to feel the flow—don't fight it, you stubborn mule.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            7.7 DELETING TEXT

x deletes a character in normal mode. 3x deletes 3 characters.  d + motion: dw
deletes word. d3w three words. d$ to end (D shortcut). 2dw = d2w.

  1. Cursor on "xabquick". 3x detles 3 characters.

--> The xabquick brown fox jumps over the lazy dog.

  2. Cursor on "quick". dw deletes "quick". Undo with u.

--> The quick brown fox jumps over the lazy dog.

  3. Now on "brown", d3w deletes "brown fox jumps". u to undo.

  4. From start, D or d$ deletes to end. However, there is no capitalized
  shortcut for d^ and d0 to delete backwards to the beginning.

  5. Now, from the middle of the line, use C to delete to the end and stay in
  insert mode. On the other hand, cc allows you to replace the whole line
  starting from the first non space character.

  6. PRO-TIP: To keep things simple, you can stick to a convention to use d
  t/T/f/F commands always while keeping the cursor on the start of a word, and
  using d t <char> to delete forwards and d F <char> to delete backwards.

--> The quick brown fox jumps over the lazy dog.

  7. Two counts: Cursor on word, 2d2w deletes two words, twice (four total).

--> Duplicate words: hello hello hello hello

  8. C-style comment hell: You type // This is my brilliant code idea and hit
  Enter, but Vim's being a smartass and auto-slaps //  on the next line. use
  CTRL+u to delete the whole damn //  prefix (it deletes the auto-generated //,
  while keeping you in insert mode). Now type your non-comment crap without the
  babysitter.

                // This is my brilliant code idea
                //

  9. Insert mode backspace woes? Ditch that finicky backspace key for Ctrl-h
  (while in insert mode): Same job—deletes one character left—but it is easier
  to reach than the backspace key.

--> hell|o world 

  10. in insert mode, place the cursor on the second l below, then use delete to
  forward delete. too bad, vim's default config maps the natural delete key
  alternative, ctrl + d, to deindent a line.  Now, place the cursor on l, and
  hit delete.

--> hell|o world 


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            7.8 JOINING TEXT

J + motion (or just J for the next line, you lazy hack): Glues lines together,
smashing that newline like it insulted your mother. Capital J adds a space; gJ
smashes without one, because sometimes you don't want Vim playing whitespace
nanny.  Counts work too—3J joins three lines down, you slob.

  1. Cursor on end of first line. J joins it to the next, adding a space. Undo
  with u, because you'll fuck it up first try.

The quick brown fox
jumps over the lazy dog.

    (After: The quick brown fox jumps over the lazy dog.)

  2. Now on "The", 3J slurps the next two lines into one big happy family. u to
  bail if it looks like ass.

The quick brown
fox jumps
over the lazy dog.

    (After: The quick brown fox jumps over the lazy dog.)

  3. From start, 3gJ joins without the extra space—perfect for code where
  whitespace is for pussies. u if you chicken out.

int main() {
printf("Hello, world!\n");
}

    (After: int main() {printf("Hello, world!\n");})

  4. Counts gone wild: Cursor on "Hello", 4gJ welds four lines (current plus
  three) into a no-space monstrosity.

Duplicate lines:
hello
hello
hello

    (After: Duplicate lines:hellohellohello)

  5. Whitespace wars: Extra blank lines pissing you off? 3J (or whatever count)
  collapses them

Line one

Line three

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            7.9 CHANGING TEXT

c + motion: cw changes word (delete to space, insert). cc whole line. c$ to end
(C shortcut).  Note: cw stops at space, dw eats it.

  1. On "fox", cw, type "cat", <esc>. See: The quick brown cat jumps...

--> The quick brown fox jumps over the lazy dog.

  2. u to undo. cc on a line, type new text.

    Old text here.

  3. From mid-line, C, type new end.

  4. Try cw again on "lazy"—note it stops at space, not like dw.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            7.10 THE . COMMAND

. repeats last delete/change. Position, dot, repeat. Godsend for boilerplate
hell.

  1. On first <B>, df> deletes to > (<B> gone).

--> <B>bold1</B> <B>bold2</B> <B>bold3</B>

  2. Move to next <B>'s <, type . to repeat.

  3. Now for change: cw on first "foo", type "bar", <Esc>.

--> foo baz foo quux foo zap

  4. Move to next "foo", . to swap it too.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            7.11 ADDING LINES IN NORMAL MODE

Look, if you're in normal mode like a newbie who forgot Esc exists, you can
still yank and paste to duplicate a damn line without fully bailing out. yy
yanks the current line, p pastes it below. On a blank line? It'll shove in
another empty turd. Don't make a habit of this hybrid bullshit; normal mode's
there for a reason.

  1. Plop your cursor on a blank line in normal mode. Hit yy—bam, yanked. Then p. 
     See the duplicate below.

--> This is your original line, you slob.
-->
--> This is your original line, you slob. 
-->

  2. Undo with u if it looks like ass. Now try it on a line with text: yy, p.
  Instant copy-paste hack.

  3. Check the indent—Vim's not stupid, it pastes clean. No extra spaces unless
  you're drunk.

  4. Abuse this on fresh lines till you get bored, then Esc out and use o like
  a grown-up.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            7.12 REPLACING CHARACTERS

r x replaces under cursor with x. 4r a replaces four with 'a'. Careful: 4rx
four x's; r4x puts '4' then dx (x as motion, idiot).

  1. On 'x', r s (one xxx becomes sxx).

    xxx lazy dog has toys.

  2. u undo. 

  3. Try 3r y on the first 'x' —replaces xxx with yyy.

  4. One fun use of the r command, is to split a line into two in normal mode.
  Place, the cursor on the whitespace after split, and hit r, followed by
  enter.

--> This is where we split the difference.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            7.13 CHANGING CASE

~ toggles case under cursor. 3~ three chars.

  1. On HELLO, 3~ flips first three: helLO

--> HELLO WORLD

  2. ~ once more on same spot: 

--> H

  3. Use g~iw to toggle the case of a word. Once you execute, you can pair it
  with the . repeat command for a smooth workflow.

--> HELLO WORLD

  4. Full line: Position start, put line in CAPS if needed, 30~ or whatever.

--> all caps rant here.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            7.14 KEYBOARD MACROS

The . command repeats the preceding change. But what if you want to do
something more complex than a single change? That's where the keyboard macros
come in. The q<character> command records keystrokes into the register named
<character> (the character must be between a and z). To finish recording, just
type a q command. You can now execute the macro by typing the @<character>
command. (This can be preceded by a count, which will cause the macro to be
executed that number of times.)

  1. You have a list of filenames like this. Move to the first character of the
  first line.

stdio.h
fcntl.h
unistd.h
stdlib.h

  2. Execute: qa to start recording in register a.

  3. ^ to beginning, i#include " to insert at start.

  4. $ to end, a" to append double quote.

  5. j to next line, q to stop recording.

  6. Now @a to play on next line. Or 2@a for the rest—bam, #include magic.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            7.15 VISUAL BLOCK MODE

Oh, for fuck's sake, if you're still editing line by line like some Emacs
weenie afraid of commitment, Visual Block Mode is your chainsaw for columnar
carnage.  Ctrl-V kicks you into block select—highlight a rectangle of text like
you're drafting a spreadsheet in hell. Then yank, delete, change the whole damn
slab at once. It's for when lines aren't aligned but you wish they were, or
you're fixing a million config files that look like drunk formatting. Load up
some ragged-ass text file, or make one with uneven columns. Don't screw around;
this mode turns you into a text-slaying machine. Or keep fumbling—your code
will thank you by crashing harder.

  1. Position cursor on first column, line 1. Ctrl-V, j twice (down two lines),
  l three times (right three chars). See the block glow?

--> Line1: abc def ghi
--> Line2: xyz jkl mno
--> Line3: pqr stu vwx

  2. With block selected, d to delete it. u to undo.

  3. Again: Ctrl-V select same block, c, type "FOO", <esc>. Fills the
  block.
  
  4. Now I for insert before: Select block on "abc", I"BAR ", <esc>—pads and inserts 
     left of block.

--> Same lines as above.

  5. A for append after: Select on "ghi", A" ZAP", <esc>, <esc>—adds right,
  pads shorter lines.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            7.16 INDENTATION COMMANDS

The Vim editor has lots of commands that help the programmer indent his program
correctly—because apparently you can't use spaces like a civilized human
without help.  The first ones discussed here merely shift the text to the left
(<<) or the right (>>).  The left shift command (<<) shifts the current line
one shift width to the left. The right shift command (>>) does the same in the
other direction. But what is a shift width?  By default, it's 8, which is about
as readable as my commit messages after a bad merge.  Studies have shown that
an indentation of 4 spaces for each level of logic is the most readable, so a
shift width of 4 would be much nicer. To change the size of the shift width,
use :set shiftwidth=4. Counts work for multiples: 2>> shifts two lines right. 

In Visual Block mode? Select your block with Ctrl-V, then >> or <<—it shifts
the whole rectangle like it should.

  1. Cursor on an unindented line. Type >> to shift right (default 8
  spaces—ugly, huh?).

if (condition) {

  2. u undo. :set shiftwidth=4, then >> again—nicer, 4 spaces.

  3. 2>> to shift current and next line right.

if (condition) {
    do_something();

  4. In Visual Block: Ctrl-V, j (down one), > (yes, just a single > is enough)
  to shift both lines' block right. Likewise, < for left. u undo.  Then keep
  using . to futher indent, and u to unindent.

Misaligned crap:
foo = bar;
baz = quux;

  5. While in insert mode use Ctrl+t to indent a line, and Ctrl+d to deindent a
  line. Your cursor can be placed anywhere in the line for this to work.

Hello, world

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            7.17 THE = COMMAND

The =motion command indents the selected text using Vim’s internal formatting
program—because who has time for manual tab wars? If you want to indent a block
of text, for example, you can use the = command to do it. The motion in this
case is the % (go to matching {}) command. =% auto-magically fixes the indent
for the brace block. Counts? =3j indents three lines down. In Visual mode,
select and =—Vim guesses smartly.

  1. Cursor on opening {. Type =% to indent the whole block.

    if (x > 0) {
                 printf("Positive");

       printf("Done"); 
                                }

  2. u undo. Select lines with V, j (visual line), = to reindent selection.

  3. =3j to indent current and next two lines. Likewise, = 3k would do the
  current and previous two lines.



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            7.18 SPLITTING THE SCREEN: BECAUSE ONE WINDOW ISN'T ENOUGH FOR YOUR
            DIVIDED ATTENTION

The :split command (or just :sp) carves up your buffer horizontally into a new
editing pane, perfect for eyeballing two parts of the same file or juggling
buffers without alt-tabbing like some Windows pleb. 

Want a vertical split?  :vsplit (:vs) slices it side-by-side, because
horizontal scrolling in a single pane is for masochists. But if you're feeling
lazy and need to run make or git blame without leaving Vim's warm embrace,
:terminal (or :term) blasts open a terminal emulator right in the
split—horizontal or vertical, your call. 

It's like having a shell that's actually useful, not some detached console
window mocking your workflow.  Counts? Nah, splits don't care about numbers;
they just obey :Nsplit for N-way madness, but don't blame me if your screen
looks like a bad merge conflict visualization.  

  1. Type :sp to horizontally split—boom, duplicate view. Simply hit :q to exit
  the split.

  2. Likewise, :vsp does a vertical split.

  3. :terminal.  It splits below, drops you in a prompt. Ctrl-w, followed by
  another w, to jump back to code pane. Exit the terminal with exit or Ctrl+d

  4. PRO-TIP: Add this to your .vimrc to open terminal with ,t and tmux with
  ,tmux

command! TMUX terminal ++close tmux new-session
let mapleader = ","
nnoremap <Leader>tmux :TMUX<CR>
nnoremap <Leader>t :terminal<CR>


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            7.19 COMPLETION: VIM'S WAY OF SAYING "YOU MEANT THAT, RIGHT?"
            BEFORE YOU INFURIATE THE MAILING LIST 

Insert mode in Vim isn't just for pounding keys like a caffeinated intern—it's
got autocomplete that pops up faster than a bug report on LKML. 

Hit Ctrl-N mid-word, and Vim scans your buffers, included files, and dictionary
for matches, cycling through with Ctrl-N/P like it's daring you to type slower. 

Too vague? Ctrl-X kicks into "completion mode," where Ctrl-X Ctrl-L grabs whole
lines, Ctrl-X Ctrl-F filenames (godsend for includes), Ctrl-X Ctrl-K dictionary
words, or Ctrl-X Ctrl-O for omnifunc if you've got syntax plugins that aren't
half-baked. It's not AI hallucinating your code; it's just Vim being smarter
than your last commit message. 

Counts?  Prefix with a number for that many completions, but honestly, who
plans that far ahead? Visual mode? Select and Ctrl-X Ctrl-O if you're fancy,
but stick to insert for the real magic.  

  1. In insert mode, halfway through "prin" for printf—Ctrl-N. Boom, popup with
  print*, printf, etc. Ctrl-N to next, Ctrl-P previous. Enter or Tab to insert,
  or Ctrl-Y to confirm without the fluff. And, use Ctrl+E to exit the dropdown,
  in the event you do not like any of the options presented.

--> prin

  2. u undo if it guessed wrong (it won't). Now try Ctrl-X Ctrl-F after
  suggests files in your pwd. Let's say you have some method called open(), now
  inside the '', hit Ctrl+X, followed by Ctrl+F.

open('')

  3. For whole-line laziness: Type gibberish, Ctrl-X Ctrl-L—Vim offers lines
  from your file matching the start. Great for duplicating boilerplate without
  copy-paste crimes.  



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                   LESSON 7 SUMMARY

  1. Add "set -o vi" to your ~/.bashrc to avoid bad habits when exiting vim.

  2. $ end (<End>), ^ first non-blank, 0/<Home> start. Counts for $.

  3. f x forward to x, F back; t x before, T before back. <Esc> abort.

  4. In insert mode, use Ctrl+O followed by a normal mode command to remain in
  insert mode even after the normal mode command executes.

  5. nG line n, G end.

  6. <C-U> half up, <C-D> half down.

  7. d motion: dw word, d3w three, d$/D end. Counts flexible.

  8. J join next line (adds space, you idiot—gJ skips it for code purists);
  count joins multiples, like 3J to mash a pile of crap into one line without
  the drama.

  9. c motion: cw word, cc line, c$/C end. cw nuance: to space.

  10. . repeats last d/c. Position and dot.

  11. Add lines in normal mode: Cursor on the line, hit yy to yank it, p to
  slap a duplicate below.

  12. r x replace (count multiples). Order matters.

  13. ~ case toggle (count range).
 
  14. q a record macro a, q stop; @a play (n@a for count).
 
  15. Ctrl-V block mode; select with hjkl, d/y/c/I/A ops; <Esc> out. Counts for
  size.
 
  16. >> right shift, << left (per line or count); :set shiftwidth=4; Visual
  Block too.
 
  17. =motion auto-indents (=% for {} block, V= for selection).
 
  18. :split splits the screen for editing, whereas :terminal splits the screen
  with a a terminal window.
 
  19. In insert mode, Ctrl+n toggles completions. We also have the Ctrl+x for
  completion mode.
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~













